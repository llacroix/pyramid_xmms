{"name":"Pyramid xmms","tagline":"XMMS2 web interface","google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","body":"Pyramid xmms2 server\r\n===================\r\n\r\nRequirements:\r\n=============\r\n\r\nIn order to run the server, you have to have xmms2 installed\r\nwith the xmmsclient python client. If you're using virtualenvs,\r\nIt might be a bit tricky. By default, --no-site-packages is used and \r\nthe xmmsclient can't be installed with setuptools. You'll have to \r\neither use site-packages or copy the xmmsclient to your virtualenv.\r\n\r\nYou'll have to use the same python binary since it is compiled with \r\nsome C bindings.\r\n\r\n\r\nSetup:\r\n======\r\n\r\nLaunching the following command will install all dependencies for the\r\nserver to run to the exception of xmmsclient.\r\n\r\n    python setup.py develop\r\n\r\nRunning\r\n=======\r\n\r\nTo run the server, you can use the following command for dev:\r\n\r\n    gunicorn_paster development.ini \r\n\r\nReplace development.ini for production.ini to use the production config file.\r\n\r\nNews:\r\n=====\r\n\r\nThe project is now using websockets. I first wrote it using long polling events but after thinking about it. Using websockes makes a lot of sense. Polling event has the advantage to work everywhere while websockets might make implementation harder with different systems or technologies. That being said. The jsonrpc api endpoint is still present. I'm going to remove the long polling part probably. What it means is that it's still possible to send jsonrpc request using plain http but it won't be possible to receive broadcasts event. \r\n\r\nWebsockets is used using jsonrpc too. So moving from one style to an other was pretty cool. The only thing that changed is the transport. I'm probably going to leave jsonrpcjs and write my own jsonrpc client for websocket transport. \r\n\r\nSo what's cool about jsonrpc + websocket. It's not exactly following the spec of jsonrpc but here's the thing. \r\n\r\nJsonrpc support doing a call with an ID... what would happen if we're doing file uploads. We could update progress through jsonrpc but how do we know where the update should go.\r\n\r\nI had in mind to do something like that: package_playlist.\r\n\r\nThis call would be used and may return multiple times. We have to setup a callback that will live x times. For example, packaging a playlist of 100 songs should return at least 100 times for each packages song. It will call the same callback with the progress and that callback knows exactly what to update. In that case, we can't use broadcasts since we'd have to define in our broadcasts a target in order to know which callback to use. And that broadcast should have a limited lifetime..\r\n\r\nBeing able to return a value multiple time is making things much easier.\r\n\r\n\r\n\r\nProjects uses:\r\n==============\r\n\r\nSome projects used for this project:\r\n\r\n- pyramid\r\n- mako\r\n- backbonejs\r\n- requiresjs\r\n- momentjs\r\n- xmmsclient\r\n- jquery \r\n- gevent\r\n- gunicorn\r\n\r\nTechnologies:\r\n=============\r\n\r\n- Async api\r\n- Websockets\r\n- Jsonrpc\r\n"}